<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules/@lblod/ember-contenteditable-editor/addon/utils/property-helpers.js - editor-documentation</title>
    <meta name="description" content="LBLOD editor Documentation pages">
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../assets/css/theme.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,600,700' rel='stylesheet' type='text/css'>
    

</head>
<body>
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <div class="navbar-header">
          <a href="../" class="navbar-brand">
              <img src="../assets/img/ember-logo.png" alt="enterprise logo">
            <span>editor-documentation</span>
          </a>
        </div>

        <div class="collapse navbar-collapse" id="nav">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="" class="fa fa-github github"></a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="main-wrapper" class="row">
        <div id="content-wrapper">
            <ol class="panel-group" id="sidebar" role="tablist" aria-multiselectable="true">
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-search-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-search" aria-expanded="true" aria-controls="collapseOne">
                        Search
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-search" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-search-heading">
                        <div class="panel-body">
                            <div id="api-tabview-filter">
                                <input type="search" id="api-filter" placeholder="Search...">
                            </div>
                        </div>
                    </div>
                </li>
                    <li class="panel panel-default">
                        <div class="panel-heading" role="tab" id="sidebar-version-heading">
                            <h4 class="panel-title">
                                <a role="button" href="/commits/2bbb5b15" target="_blank">
                                  Tag: 0.0.0.2bbb5b15
                                </a>
                            </h4>
                        </div>
                    </li>
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-modules-heading">
                        <h4 class="panel-title">
                    <a role="button" data-toggle="collapse" href="#sidebar-modules" aria-expanded="true" aria-controls="collapseOne">
                      Modules
                    </a>
                  </h4>
                    </div>
                    <div id="sidebar-modules" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-modules-heading">
                        <div class="panel-body">
                                <ol>
                                        <li>
                                            <a href="../modules/contenteditable-editor.html">contenteditable-editor</a>
                                        </li>
                                        <li>
                                            <a href="../modules/editor-core.html">editor-core</a>
                                        </li>
                                        <li>
                                            <a href="../modules/pernetApi.html">pernetApi</a>
                                        </li>
                                        <li>
                                            <a href="../modules/rdfa-editor.html">rdfa-editor</a>
                                        </li>
                                </ol>
                        </div>
                    </div>
                </li>
            
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-classes-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-classes" aria-expanded="true" aria-controls="collapseOne">
                        Classes
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-classes" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-classes-heading">
                        <div class="panel-body">
                            <ol>
                                    <li>
                                        <a href="../classes/ArrowHandler.html">ArrowHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/BackspaceHandler.html">BackspaceHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/BoldProperty.html">BoldProperty</a>
                                    </li>
                                    <li>
                                        <a href="../classes/CappedHistory.html">CappedHistory</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ContentEditableComponent.html">ContentEditableComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/DocumentStructureComponent.html">DocumentStructureComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/DomHelpers.html">DomHelpers</a>
                                    </li>
                                    <li>
                                        <a href="../classes/EditorProperty.html">EditorProperty</a>
                                    </li>
                                    <li>
                                        <a href="../classes/EmphasisMarkdownHandler.html">EmphasisMarkdownHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/EnterHandler.html">EnterHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/EventProcessor.html">EventProcessor</a>
                                    </li>
                                    <li>
                                        <a href="../classes/HandlerResponse.html">HandlerResponse</a>
                                    </li>
                                    <li>
                                        <a href="../classes/HeaderMarkdownHandler.html">HeaderMarkdownHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/HintsRegistry.html">HintsRegistry</a>
                                    </li>
                                    <li>
                                        <a href="../classes/HintsRegistryDebugger.html">HintsRegistryDebugger</a>
                                    </li>
                                    <li>
                                        <a href="../classes/IgnoreModifiersHandler.html">IgnoreModifiersHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ItalicProperty.html">ItalicProperty</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ListInsertionMarkdownHandler.html">ListInsertionMarkdownHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/NodeWalker.html">NodeWalker</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RawEditor.html">RawEditor</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaBackspaceHandler.html">RdfaBackspaceHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaBlock.html">RdfaBlock</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaContextDebugger.html">RdfaContextDebugger</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaContextScanner.html">RdfaContextScanner</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorComponent.html">RdfaEditorComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorDebugger.html">RdfaEditorDebugger</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorDispatcher.html">RdfaEditorDispatcher</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorLoadMonitor.html">RdfaEditorLoadMonitor</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorSuggestedHintsComponent.html">RdfaEditorSuggestedHintsComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorToolbarComponent.html">RdfaEditorToolbarComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RichNode.html">RichNode</a>
                                    </li>
                                    <li>
                                        <a href="../classes/TextInputHandler.html">TextInputHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/UnderlineProperty.html">UnderlineProperty</a>
                                    </li>
                            </ol>
                        </div>
                    </div>
                </li>
            </ol>
            <div class="content-container">
                <div class="apidocs">
                    <div id="docs-main">
                        <div class="content">
<div class="page-header">
    <h1><i class="fa fa-file-code-o" aria-hidden="true"></i>  File</h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
import { warn } from &#x27;@ember/debug&#x27;;
import flatMap from &#x27;./flat-map&#x27;;
import {
  tagName,
  removeNodeFromTree as unwrapDOMNode
} from &#x27;./dom-helpers&#x27;;
import ReplaceWithPolyfill from &#x27;mdn-polyfills/Node.prototype.replaceWith&#x27;;
import RichNode from &#x27;@lblod/marawa/rich-node&#x27;;
import { DEFAULT_TAG_NAME } from &#x27;./editor-property&#x27;;
import {
  replaceRichNodeWith,
  wrapRichNode,
  unwrapRichNode
} from &#x27;./rich-node-tree-modification&#x27;;

// TODO: find a clean spot for this polyfill
if (!Element.prototype.replaceWith)
  Element.prototype.replaceWith = ReplaceWithPolyfill;
if (!CharacterData.prototype.replaceWith)
  CharacterData.prototype.replaceWith = ReplaceWithPolyfill;
if (!DocumentType.prototype.replaceWith)
  DocumentType.prototype.replaceWith = ReplaceWithPolyfill;

/**
 * verifies if a property is enabled on all leaf nodes of the supplied richNode
 * @method propertyIsEnabledOnLeafNodes
 * @return boolean
 */
function propertyIsEnabledOnLeafNodes(richnode, property) {
  const hasChildren = child =&gt; { return ( child &amp;&amp; ((! child.children) ||  child.children.length === 0))};
  const leafNodes = flatMap(richnode, hasChildren);
  const leafNodesWhereStyleIsNotAppliedExists =  leafNodes.some((n) =&gt; n.type !== &quot;other&quot; &amp;&amp; !property.enabledAt(n)) ;
  return ! leafNodesWhereStyleIsNotAppliedExists;
}


/**
 * We need to apply or remove a property to all portions of text based on the output
 * contained in them.  We can split the important nodes in three
 * pieces:
 *
 * - start: text nodes which contain partial content to highlight
 * - middle: rich nodes which are the highest parent of a text node that are still contained in the selected range
 * - end: trailing text nodes which contain partial content to highlight
 *
 * Detecting this range is tricky
 *
 * @method findSuitableNodesToApplyOrCancelProperty
 * @param Selection selection
 * @return Array array of selections
 */
function findSuitableNodesToApplyOrCancelProperty(selection) {
  if (!selection.selectedHighlightRange) {
    // TODO: support context selections as well
    // this might be fairly trivial but focussing on text selection for now
    throw new Error(&#x27;currently only selectedHighlightRange is supported&#x27;);
  }
  const nodes = [];
  const domNodes = [];
  const start = Math.min(...selection.selections.map( x =&gt; x.range[0]));
  const end = Math.max(...selection.selections.map( x =&gt; x.range[1]));
  for (let {richNode, range} of selection.selections) {
    if (richNode.start &lt; start || richNode.end &gt; end) {
      // this node only partially matches the selected range
      // so it needs to be split up later and we can&#x27;t walk up the tree.
      if (!domNodes.includes(richNode.domNode)) {
        nodes.push({richNode, range});
        domNodes.push(richNode.domNode);
      }
    }
    else {
      // walk up the tree as longs as we fit within the range and don&#x27;t encounter a block or list item
      let current = richNode;
      const isBlock = function(node) {
        if (node.type !== &quot;tag&quot;)
          return false;
        else {
          const displayStyle = window.getComputedStyle(node.domNode)[&#x27;display&#x27;];
          return displayStyle == &#x27;block&#x27; || displayStyle == &#x27;list-item&#x27;;
        }
      };
      while(current.parent &amp;&amp; current.parent.start &gt;= start &amp;&amp; current.parent.end &lt;= end &amp;&amp; ! isBlock(current)) {
        current = current.parent;
      }
      if (!domNodes.includes(current.domNode)) {
        nodes.push({richNode: current, range: [current.start, current.end]});
        domNodes.push(current.domNode);
      }
    }
  }
  return nodes;
}

/**
 * apply a property to an existing dom node
 * @method rawApplyProperty
 * @param DOMElement domNode
 * @param EditorProperty property
 */
function rawApplyProperty(domNode, property) {
  for (let attribute of Object.keys(property.attributes)) {
    if(domNode.hasAttribute(attribute)) {
      const previousValue = domNode.getAttribute(attribute);
      domNode.setAttribute(attribute, &#x60;${previousValue} ${property.attributes[attribute]}&#x60;);
    }
    else {
      domNode.setAttribute(attribute, property.attributes[attribute]);
    }
  }
}

/**
 * creates a new DOMElement in line with the property specification
 * @method createWrapperForProperty
 * @param EditorProperty property
 */
function createWrapperForProperty(property) {
  const tag = document.createElement(property.tagName);
  for (let attribute of Object.keys(property.attributes)) {
    tag.setAttribute(attribute, property.attributes[attribute]);
  }
  return tag;
}


/**
 * apply a property to a selection
 * @method applyProperty
 * @param selection
 * @param document, should provide a pernet api
 * @param property an editor property
 */
function applyProperty(selection, doc, property, calledFromCancel) {
  if (selection.selections.length === 0) {
    warn(&#x60;can&#x27;t apply property to empty selection&#x60;, {id: &#x27;content-editable.editor-property&#x27;});
    return;
  }

  let nodesToApplyPropertyOn = findSuitableNodesToApplyOrCancelProperty(selection);
  if (!calledFromCancel) {
    // cancel first to avoid duplicate tags
    cancelProperty(selection, doc, property);
  }
  // clean up the selection to limit overlap with cancel
  const start = nodesToApplyPropertyOn.map((n) =&gt; n.start).sort()[0];
  const end = nodesToApplyPropertyOn.map((n) =&gt; n.end).sort().reverse()[0];
  // clean up empty nodes at start and end
  nodesToApplyPropertyOn = nodesToApplyPropertyOn.filter((node) =&gt; !(node.richNode.start === start &amp;&amp; node.richNode.end === start)).filter((node) =&gt; node &amp;&amp; !(node.richNode.start === end &amp;&amp; node.richNode.end === end));
  // selectHighlight can return the last position or first position of text nodes which are irrelevant here
  // keeping them would cause the creation of empty tags that we just need to clean up afterwards

  nodesToApplyPropertyOn = nodesToApplyPropertyOn.filter((s) =&gt; !(s.range[0] - s.range[1] === 0 &amp;&amp; s.richNode.end - s.richNode.start &gt; 0));

  for( let {richNode, range} of nodesToApplyPropertyOn) {
    const [start,end] = range;
    if (richNode.type ===  &quot;tag&quot; ) {
      if (richNode.start &lt; start || richNode.end &gt; end) {
        warn(&#x60;applyProperty does not support applying a property to a tag that only partially matches the range&#x60;, {id: &quot;content-editable.highlight&quot;});
      }
      else if (!domNodeContainsProperty(richNode.domNode, property)) {
        const domNode = richNode.domNode;
        let node;
        if (property.newContext) {
          node = createWrapperForProperty(property);
          domNode.prepend(node); // add node as child
          while(node.nextSibling) { // move other children to wrapper
            node.append(node.nextSibling);
          }
          wrapRichNode(richNode, node);
        }
        else {
          rawApplyProperty(richNode.domNode, property);
        }
      }
    }
    else if (richNode.type === &quot;text&quot;) {
      const relativeStart = Math.max(start - richNode.start, 0);
      const relativeEnd = Math.min(end - richNode.start, richNode.text.length);
      const [preText, infixText, postText] =
            [ richNode.text.slice( 0, relativeStart ),
              richNode.text.slice( relativeStart, relativeEnd ),
              richNode.text.slice( relativeEnd ) ];
      const prefixNode = preText == &quot;&quot; ? null : document.createTextNode( preText );
      const infixNode = createWrapperForProperty(property);
      const infixTextNode = document.createTextNode( infixText );
      infixNode.appendChild( infixTextNode );
      const postfixNode = postText == &quot;&quot; ? null : document.createTextNode( postText );
      const newDomNodes = [prefixNode,infixNode,postfixNode].filter( (x) =&gt; x );
      // update the DOM tree
      richNode.domNode.replaceWith( ...newDomNodes);
      const preRichNode = ! prefixNode ? null : new RichNode({
        domNode: prefixNode,
        parent: richNode.parent,
        start: richNode.start,
        end: start,
        text: preText,
        type: &quot;text&quot;
      });
      const infixRichNode = ! infixNode ? null : new RichNode({
        domNode: infixNode,
        parent: richNode.parent,
        start: start,
        end: end,
        text: infixText,
        type: &quot;tag&quot;
      });
      infixRichNode.children = [ new RichNode({
        domNode: infixTextNode,
        parent: infixRichNode,
        start: start,
        end: end,
        text: infixText, // TODO: remove if consuming code doesn&#x27;t use the TextNodeWalker
        type: &quot;text&quot;
      }) ];
      const postfixRichNode = ! postfixNode ? null : new RichNode({
        domNode: postfixNode,
        parent: richNode.parent,
        start: end,
        end: end + postText.length,
        text: postText,
        type: &quot;text&quot;
      });
      const newRichNodes = [];
      if( preRichNode ) { newRichNodes.push( preRichNode ); }
      newRichNodes.push( infixRichNode );
      if( postfixRichNode ) { newRichNodes.push( postfixRichNode ); }
      replaceRichNodeWith(richNode, newRichNodes);
    }
    else {
      warn( &quot;applying a property can only occur on text nodes or on tag nodes&quot;, {id: &quot;content-editable.editor-property&quot;} );
    }
  }
}

/**
 * remove a property from a richNode
 */
function rawCancelProperty(richNode, property) {
  if (richNode.type === &#x27;tag&#x27;) {
    if (domNodeIsEqualToProperty(richNode.domNode,property)) {
      // dom node matches the property completely, no extra info set
      unwrapDOMNode(richNode.domNode);
      unwrapRichNode(richNode);
    }
    else if (domNodeContainsProperty(richNode.domNode, property)) {
      // dom node has the correct tag and attributes, but has more information
      // only remove property related information
      for (let key of Object.keys(property.attributes)) {
        // clean up attributes
        // TODO: if an attribute is multivalue (e.g space separated) this assumes attribute order from the property is maintained
        const oldValue = richNode.domNode.getAttribute(key);
        const updatedValue = oldValue.replace(property.attributes[key], &#x27;&#x27;);
        if (updatedValue.length === 0)
          richNode.domNode.removeAttribute(key);
        else
          richNode.domNode.setAttribute(key, updatedValue);
      }
      if (tagName(richNode.domNode) === property.tagName &amp;&amp; property.tagName !== DEFAULT_TAG_NAME) {
        // change the tagname to a neutral tag name, assumes tagname of property has semantic or graphical meaning
        // this can&#x27;t be done dynamically so we have to create new node and replace the previous one
        const newNode = document.createElement(DEFAULT_TAG_NAME); // TODO have to pick a default, is this sane?
        for(let a of richNode.domNode.attributes) {
          newNode.setAttribute(a.nodeName, a.nodeValue);
        }
        while (richNode.domNode.firstChild) {
          newNode.appendChild(richNode.domNode.firstChild);
        }
        richNode.domNode.replaceWith(newNode);
        const newRichNode = new RichNode({
          type: &#x27;tag&#x27;,
          domNode: newNode,
          start: richNode.start,
          end: richNode.end,
          children: richNode.children,
          parent: richNode.parent
        });
        replaceRichNodeWith(richNode, newRichNode);
      }
    }
    else if (richNode.children &amp;&amp; richNode.children.length &gt; 0) {
      // walk down, property was not defined here
      for (let child of richNode.children) {
        if (child.type === &#x27;tag&#x27;)
          rawCancelProperty(child, property);
      }
    }
    else {
      //no children but it&#x27;s a tag, so nothing to do ?
    }
  }
  else {
    // can only cancel on a tag, do nothing
  }
}
/*
 * predicate to evaluate if a property completely matches a dom node
 */
function domNodeIsEqualToProperty(domNode, property) {
  const tagNameMatch = property.tagName === tagName(domNode);
  let attributesMatch = true;
  for (let key of Object.keys(property.attributes)) {
    if (!domNode.hasAttribute(key) || domNode.getAttribute(key) !== new String(property.attributes[key]).toString()) {
      attributesMatch = false;
    }
  }
  for (let attribute of domNode.attributes) {
    if (!property.attributes[attribute.nodeName]) {
      attributesMatch = false;
    }
  }
  return tagNameMatch &amp;&amp; attributesMatch;
}

/*
 * predicate to evaluate if a property matches a dom node, other attributes can be present on the dom node
 */
function domNodeContainsProperty(domNode, property) {
  const tagNameMatch = property.tagName === tagName(domNode);
  let attributesMatch = true;
  for (let key of Object.keys(property.attributes)) {
    if (!domNode.hasAttribute(key) || ! domNode.getAttribute(key).includes(property.attributes[key]))
      attributesMatch = false;
  }
  return (tagNameMatch || ! property.newContext) &amp;&amp; attributesMatch; //TODO is this correct?!
}


 /**
 * cancel a property on a selection
 * @method cancelProperty
 * @param selection
 * @param document, should provide a pernet api
 * @param property an editor property
 */
function cancelProperty(selection, doc, property) {
  if (selection.selections.length === 0) {
    warn(&#x60;can&#x27;t cancel property on empty selection&#x60;, {id: &#x27;content-editable.editor-property&#x27;});
    return;
  }
  const nodesToCancelPropertyOn = findSuitableNodesToApplyOrCancelProperty(selection);
  for( let {richNode, range} of nodesToCancelPropertyOn) {
    const [start,end] = range;
    if (richNode.type ===  &quot;tag&quot;) {
      if (richNode.start &lt; start || richNode.end &gt; end) {
        warn(&#x60;cancelProperty does not support cancelling a property to a tag that only partially matches the range&#x60;, {id: &quot;content-editable.editor-property&quot;} );
      }
      else {
          rawCancelProperty(richNode, property);
      }
    }
    else if (richNode.type === &quot;text&quot;) {
      // we should cancel the property on part of the string, we need to find a parent that is setting the property and cancel that
      // then reapply the property to the pre and post fix nodes
      let currentNode = richNode.parent;
      while(currentNode.parent &amp;&amp; !domNodeContainsProperty(currentNode.domNode, property)) {
        currentNode = currentNode.parent;
      }
      if (domNodeContainsProperty(currentNode.domNode,property)) {
        rawCancelProperty(currentNode, property);
        if (currentNode.start &lt; start) {
          // reapply property on prefix
          const sel = doc.selectHighlight([currentNode.start, start]);
          applyProperty(sel, doc, property, true);
        }
        if (currentNode.end &gt; end) {
          // reapply property on postfix
          const sel = doc.selectHighlight([ end+1, currentNode.end]);
          applyProperty(sel, doc, property, true);
        }
      }
      else if (propertyIsEnabledOnLeafNodes(currentNode, property)) {
        // we didn&#x27;t find where the property was applied, it could be that this property was enabled in a manner we don&#x27;t yet understand
        // probably need a cancelling wrapper
        // TODO
        warn(&#x60;did not find node that enabled property&#x60;, {id: &#x27;contenteditable.property&#x27;});
      }
      else {
        // property doesn&#x27;t seem to be enabled at all
        warn(&#x60;request to cancel a property, but it wasn&#x27;t enabled&#x60;, {id: &#x27;contenteditable.property&#x27;});
      }
    }
    else {
      warn( &quot;cancelling a property can only occur on text nodes or on tag nodes&quot;, {id: &quot;content-editable.editor-property&quot;} );
    }
  }
}


export { cancelProperty, applyProperty }

    </pre>
</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script>prettyPrint();</script>
    <script src="../assets/vendor/jquery/jquery.min.js"></script>
    <script src="../assets/vendor/jquery-ui/jquery-ui.min.js"></script>
    <script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
    <script src="../assets/vendor/github-slugger/slugger.js"></script>
    <script src="../assets/js/yuidoc-bootstrap.js"></script>
</body>
</html>
