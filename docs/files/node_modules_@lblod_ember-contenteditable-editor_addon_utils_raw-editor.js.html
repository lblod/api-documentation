<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules/@lblod/ember-contenteditable-editor/addon/utils/raw-editor.js - editor-documentation</title>
    <meta name="description" content="LBLOD editor Documentation pages">
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../assets/css/theme.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,600,700' rel='stylesheet' type='text/css'>
    

</head>
<body>
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <div class="navbar-header">
          <a href="../" class="navbar-brand">
              <img src="../assets/img/ember-logo.png" alt="enterprise logo">
            <span>editor-documentation</span>
          </a>
        </div>

        <div class="collapse navbar-collapse" id="nav">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="" class="fa fa-github github"></a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="main-wrapper" class="row">
        <div id="content-wrapper">
            <ol class="panel-group" id="sidebar" role="tablist" aria-multiselectable="true">
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-search-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-search" aria-expanded="true" aria-controls="collapseOne">
                        Search
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-search" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-search-heading">
                        <div class="panel-body">
                            <div id="api-tabview-filter">
                                <input type="search" id="api-filter" placeholder="Search...">
                            </div>
                        </div>
                    </div>
                </li>
                    <li class="panel panel-default">
                        <div class="panel-heading" role="tab" id="sidebar-version-heading">
                            <h4 class="panel-title">
                                <a role="button" href="/commits/2bbb5b15" target="_blank">
                                  Tag: 0.0.0.2bbb5b15
                                </a>
                            </h4>
                        </div>
                    </li>
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-modules-heading">
                        <h4 class="panel-title">
                    <a role="button" data-toggle="collapse" href="#sidebar-modules" aria-expanded="true" aria-controls="collapseOne">
                      Modules
                    </a>
                  </h4>
                    </div>
                    <div id="sidebar-modules" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-modules-heading">
                        <div class="panel-body">
                                <ol>
                                        <li>
                                            <a href="../modules/contenteditable-editor.html">contenteditable-editor</a>
                                        </li>
                                        <li>
                                            <a href="../modules/editor-core.html">editor-core</a>
                                        </li>
                                        <li>
                                            <a href="../modules/pernetApi.html">pernetApi</a>
                                        </li>
                                        <li>
                                            <a href="../modules/rdfa-editor.html">rdfa-editor</a>
                                        </li>
                                </ol>
                        </div>
                    </div>
                </li>
            
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-classes-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-classes" aria-expanded="true" aria-controls="collapseOne">
                        Classes
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-classes" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-classes-heading">
                        <div class="panel-body">
                            <ol>
                                    <li>
                                        <a href="../classes/ArrowHandler.html">ArrowHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/BackspaceHandler.html">BackspaceHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/BoldProperty.html">BoldProperty</a>
                                    </li>
                                    <li>
                                        <a href="../classes/CappedHistory.html">CappedHistory</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ContentEditableComponent.html">ContentEditableComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/DocumentStructureComponent.html">DocumentStructureComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/DomHelpers.html">DomHelpers</a>
                                    </li>
                                    <li>
                                        <a href="../classes/EditorProperty.html">EditorProperty</a>
                                    </li>
                                    <li>
                                        <a href="../classes/EmphasisMarkdownHandler.html">EmphasisMarkdownHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/EnterHandler.html">EnterHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/EventProcessor.html">EventProcessor</a>
                                    </li>
                                    <li>
                                        <a href="../classes/HandlerResponse.html">HandlerResponse</a>
                                    </li>
                                    <li>
                                        <a href="../classes/HeaderMarkdownHandler.html">HeaderMarkdownHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/HintsRegistry.html">HintsRegistry</a>
                                    </li>
                                    <li>
                                        <a href="../classes/HintsRegistryDebugger.html">HintsRegistryDebugger</a>
                                    </li>
                                    <li>
                                        <a href="../classes/IgnoreModifiersHandler.html">IgnoreModifiersHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ItalicProperty.html">ItalicProperty</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ListInsertionMarkdownHandler.html">ListInsertionMarkdownHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/NodeWalker.html">NodeWalker</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RawEditor.html">RawEditor</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaBackspaceHandler.html">RdfaBackspaceHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaBlock.html">RdfaBlock</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaContextDebugger.html">RdfaContextDebugger</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaContextScanner.html">RdfaContextScanner</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorComponent.html">RdfaEditorComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorDebugger.html">RdfaEditorDebugger</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorDispatcher.html">RdfaEditorDispatcher</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorLoadMonitor.html">RdfaEditorLoadMonitor</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorSuggestedHintsComponent.html">RdfaEditorSuggestedHintsComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RdfaEditorToolbarComponent.html">RdfaEditorToolbarComponent</a>
                                    </li>
                                    <li>
                                        <a href="../classes/RichNode.html">RichNode</a>
                                    </li>
                                    <li>
                                        <a href="../classes/TextInputHandler.html">TextInputHandler</a>
                                    </li>
                                    <li>
                                        <a href="../classes/UnderlineProperty.html">UnderlineProperty</a>
                                    </li>
                            </ol>
                        </div>
                    </div>
                </li>
            </ol>
            <div class="content-container">
                <div class="apidocs">
                    <div id="docs-main">
                        <div class="content">
<div class="page-header">
    <h1><i class="fa fa-file-code-o" aria-hidden="true"></i>  File</h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
import EmberObject, { get, computed } from &#x27;@ember/object&#x27;;
import { debug, warn } from &#x27;@ember/debug&#x27;;
import { A } from &#x27;@ember/array&#x27;;
import { task, timeout } from &#x27;ember-concurrency&#x27;;
import DiffMatchPatch from &#x27;diff-match-patch&#x27;;
import { walk as walkDomNode } from &#x27;@lblod/marawa/node-walker&#x27;;
import {
  isDisplayedAsBlock,
  invisibleSpace,
  insertTextNodeWithSpace,
  insertNodeBAfterNodeA,
  sliceTextIntoTextNode,
  removeNode,
  isVoidElement,
  isIgnorableElement,
  tagName,
  createElementsFromHTML
} from &#x27;./dom-helpers&#x27;;
import getRichNodeMatchingDomNode from &#x27;./get-rich-node-matching-dom-node&#x27;;
import CappedHistory from &#x27;./capped-history&#x27;;
import forgivingAction from &#x27;./forgiving-action&#x27;;
import replaceTextWithHtml from &#x27;./replace-text-with-html&#x27;;
import flatMap from &#x27;./flat-map&#x27;;
import {
  getTextContent,
  processDomNode as walkDomNodeAsText
} from &#x27;./text-node-walker&#x27;;
import previousTextNode from &#x27;./previous-text-node&#x27;;
import nextTextNode from &#x27;./next-text-node&#x27;;
import {
  unorderedListAction,
  orderedListAction,
  indentAction,
  unindentAction
} from &#x27;./list-helpers&#x27;;
import { applyProperty, cancelProperty } from &#x27;./property-helpers&#x27;;
import highlightProperty from &#x27;./highlight-property&#x27;;
import { analyse as scanContexts } from &#x27;@lblod/marawa/rdfa-context-scanner&#x27;;
import {
  selectCurrentSelection,
  selectHighlight,
  selectContext,
  update,
  replaceDomNode
} from &#x27;./editor&#x27;;

const NON_BREAKING_SPACE = &#x27;\u00A0&#x27;;

/**
 * raw contenteditable editor, a utility class that shields editor internals from consuming applications.
 *
 * @module contenteditable-editor
 * @class RawEditor
 * @constructor
 * @extends EmberObject
 */
class RawEditor extends EmberObject.extend({
  /**
   * Called after relevant input. Checks content and calls closureActions when changes detected
   * handleTextInsert, handleTextRemove, handleFullContentUpdate
   * @method generateDiffEvents
   *
   * @param {Array} Optional argument pass info to event consumers.
   * @public !!
   */
  generateDiffEvents: task(function* (extraInfo = []){
    yield timeout(320);

    let newText = getTextContent(this.get(&#x27;rootNode&#x27;));
    let oldText = this.get(&#x27;currentTextContent&#x27;);
    const dmp = new DiffMatchPatch();
    let differences = dmp.diff_main(oldText, newText);
    let pos = 0;
    let textHasChanges = false;

    differences.forEach( ([mode, text]) =&gt; {
      if (mode === 1) {
        textHasChanges = true;
        this.set(&#x27;currentTextContent&#x27;, oldText.slice(0, pos) + text + oldText.slice(pos, oldText.length));
        this.textInsert(pos, text, extraInfo);
        pos = pos + text.length;
      }
      else if (mode === -1) {
        textHasChanges = true;
        this.set(&#x27;currentTextContent&#x27;, oldText.slice(0,pos) + oldText.slice(pos + text.length, oldText.length));
        forgivingAction(&#x27;textRemove&#x27;, this)(pos, pos + text.length, extraInfo);
      }
      else {
        pos = pos + text.length;
      }
      oldText = this.get(&#x27;currentTextContent&#x27;);
    }, this);

    if(textHasChanges){
      if ( ! extraInfo.some( (x) =&gt; x.noSnapshot)) {
        this.createSnapshot();
      }
      forgivingAction(&#x27;handleFullContentUpdate&#x27;, this)(extraInfo);
    }
  }).restartable()
}) {

  /**
   * root node of the editor
   * @property rootNode
   * @type DOMNode
   * @public
   */
  rootNode =  null

  /**
   * richNode, a rich representation of the dom tree created with NodeWalker
   * @property richNode
   * @type RichNode
   * @public
   */
  richNode = null

  /**
   * the current selection in the editor
   * @property currentSelection
   * @type Array
   * @public
   *
   * NOTE: don&#x27;t change this in place
   */
  currentSelection = null

  /**
   * the start of the current range
   *
   * NOTE: this is correctly bound because currentSelection is never
   * changed in place
   */
  @computed(&#x27;currentSelection&#x27;)
  get currentPosition() {
    return this.currentSelection[0];
  }

  /**
   * the domNode containing our caret
   *
   * NOTE: is set to null on a selection that spans nodes
   * @property currentNode
   * @type DomNode
   * @public
   */
  _currentNode = null

  get currentNode() {
    return this._currentNode;
  }

  set currentNode( node ) {
    // clean old marks
    for( let oldNode of document.querySelectorAll(&quot;[data-editor-position-level]&quot;) ) {
      oldNode.removeAttribute(&quot;data-editor-position-level&quot;);
    }
    // clean old RDFa marks
    for( let oldNode of document.querySelectorAll(&quot;[data-editor-rdfa-position-level]&quot;) ) {
      oldNode.removeAttribute(&quot;data-editor-rdfa-position-level&quot;);
    }

    // set current node
    this._currentNode = node;

    // add new marks
    let counter=0;
    let walkedNode = node;
    while( walkedNode ) {
      if( tagName( walkedNode ) )
        walkedNode.setAttribute(&quot;data-editor-position-level&quot;, counter++);
      walkedNode = walkedNode.parentNode;
    }
    // add new rdfa marks
    let rdfaCounter=0;
    walkedNode = node;
    while( walkedNode ) {
      if( tagName( walkedNode ) ) {
        let isSemanticNode =
            [&quot;about&quot;,&quot;content&quot;,&quot;datatype&quot;,&quot;property&quot;,&quot;rel&quot;,&quot;resource&quot;,&quot;rev&quot;,&quot;typeof&quot;]
            .find( (name) =&gt; walkedNode.hasAttribute(name) );
        if( isSemanticNode )
          walkedNode.setAttribute(&quot;data-editor-rdfa-position-level&quot;, rdfaCounter++);
      }
      walkedNode = walkedNode.parentNode;
    }
  }

  /**
   * current textContent from editor
   *
   * @property currentTextContent
   * @type String
   * @public
   */
  currentTextContent = null

  /**
   * components present in the editor
   * @property components
   * @type {Object}
   * @public
   */
  components = null

  /**
   * is current selection a cursor
   * @property currentSelectionIsACursor
   * @type boolean
   * @public
   */
  @computed(&#x27;currentSelection&#x27;)
  get currentSelectionIsACursor() {
    let sel = this.currentSelection;
    return sel[0] === sel[1];
  }
  applyProperty(selection, property) {
    applyProperty(selection, this, property);
  }
  cancelProperty(selection, property) {
    cancelProperty(selection, this, property);
  }

  togglePropertyAtCurrentPosition(property) {
    const wasEnabled = property.enabledAt(this.getRichNodeFor(this.currentNode));
    const selection = this.selectHighlight(this.currentSelection);
    const textNodeAtCurrentPosition = (node) =&gt; node.type === &#x27;text&#x27; &amp;&amp; node.start &lt;= this.currentPosition &amp;&amp; node.end &gt;= this.currentPosition;
    if (wasEnabled) {
      cancelProperty(selection, this, property);
      const correctNode = flatMap(this.richNode, (node) =&gt; textNodeAtCurrentPosition(node) &amp;&amp; ! property.enabledAt(node), true)[0];
      this.setCarret(correctNode.domNode, this.currentPosition - correctNode.start);
    }
    else {
      applyProperty(selection, this, property);
      const correctNode = flatMap(this.richNode, (node) =&gt; textNodeAtCurrentPosition(node) &amp;&amp; property.enabledAt(node), true)[0];
      this.setCarret(correctNode.domNode, this.currentPosition - correctNode.start);
    }
  }
  toggleProperty(selection, property) {
    const richNodes = selection.selections.map((s) =&gt; s.richNode);
    const start = richNodes.map((n) =&gt; n.start).sort()[0];
    const end = richNodes.map((n) =&gt; n.end).sort().reverse()[0];

    // check if property is enabled on any non empty text node, these are the only visible nodes
    const filteredNodes = richNodes.filter((node) =&gt; !(node.start === start &amp;&amp; node.end === start)).filter((node) =&gt; !(node.start === end &amp;&amp; node.end === end));
    const enabled = filteredNodes.some( (node) =&gt; node.type === &#x27;text&#x27; &amp;&amp; property.enabledAt(node));
    if (enabled) {
      this.cancelProperty(selection, property);
    }
    else {
      this.applyProperty(selection, property);
    }
  }

  constructor(){
    super(...arguments);
    this.set(&#x27;history&#x27;, CappedHistory.create({ maxItems: 100}));
    this.set(&#x27;components&#x27;, A());
  }

  /**
   *
   * @method replaceTextWithHTML
   * @param {Number} start index absolute
   * @param {Number} end index absolute
   * @param {String} html string
   * @param {Array} Optional extra info, which will be passed around when triggering update events.
   * @public
   */
  replaceTextWithHTML(start, end, html, extraInfo = []) {
    this.createSnapshot();
    let newNodes = replaceTextWithHtml(this.richNode, start, end, html);
    let contentLength = newNodes.map( node =&gt; getTextContent(node).length).reduce( (total, i) =&gt; total + i);
    var nextSibling = newNodes[newNodes.length-1].nextSibling;
    if (nextSibling === null || nextSibling.nodeType !== Node.TEXT_NODE) {
      nextSibling = document.createTextNode(invisibleSpace);
      insertNodeBAfterNodeA(newNodes[0].parentNode, newNodes[newNodes.length-1], nextSibling);
    }
    this.updateRichNode();
    this.set(&#x27;currentNode&#x27;, nextSibling );
    this.setCurrentPosition(start + contentLength);
    this.generateDiffEvents.perform(extraInfo);
    forgivingAction(&#x27;elementUpdate&#x27;, this)();
    return newNodes;
  }

  /**
   * replaces dom node with html string.
   * @method replaceNodeWithHTML
   * @param {Object} DomNode to work on
   * @param {Object} string containing html
   * @param {Boolean} instructive to place cursor after inserted HTML,
   * @param {Array} Optional extra info, which will be passed around when triggering update events.
   *
   * @return returns inserted domNodes (with possibly an extra trailing textNode).
   * @public
   */
  replaceNodeWithHTML(node, html, placeCursorAfterInsertedHtml = false, extraInfo = []){
    //TODO: make sure the elements to insert are non empty when not allowed, e.g. &lt;div&gt;&lt;/div&gt;
    //TODO: think: what if htmlstring is &quot;&lt;div&gt;foo&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;&quot; -&gt; do we need to force a textnode in between?

    //keeps track of current node.
    let getCurrentCarretPosition = this.getRelativeCursorPosition();
    let currentNode = this.currentNode;

    let keepCurrentPosition = !placeCursorAfterInsertedHtml &amp;&amp; !node.isSameNode(currentNode) &amp;&amp; !node.contains(currentNode);

    if(!placeCursorAfterInsertedHtml &amp;&amp; (node.isSameNode(currentNode) || node.contains(currentNode)))
      warn(&#x60;Current node is same or contained by node to replace. Current node will change.&#x60;,
           {id: &#x27;contenteditable.replaceNodeWithHTML.currentNodeReplace&#x27;});

    //find rich node matching dom node
    let richNode = this.getRichNodeFor(node);
    if(!richNode) return null;

    let richParent = richNode.parent;
    if (!richParent) return null;

    //insert new nodes first
    let domNodesToInsert = createElementsFromHTML(html);

    let lastInsertedRichElement = this.insertElementsAfterRichNode(richParent, richNode, domNodesToInsert);
    lastInsertedRichElement = this.insertValidCursorNodeAfterRichNode(richParent, lastInsertedRichElement);

    // proceed with removal
    removeNode(richNode.domNode);

    //update editor state
    const textNodeAfterInsert = !keepCurrentPosition ? nextTextNode(lastInsertedRichElement.domNode) : null;
    this.updateRichNode();
    this.generateDiffEvents.perform(extraInfo);
    if(keepCurrentPosition) {
      this.setCarret(currentNode, getCurrentCarretPosition);
    }
    else {
      this.setCarret(textNodeAfterInsert,0);
    }
    if(lastInsertedRichElement.domNode.isSameNode(domNodesToInsert.slice(-1)[0]))
      return domNodesToInsert;
    return [...domNodesToInsert, lastInsertedRichElement.domNode];
  }

  /**
   * removes a node. If node to be removed is contains current cursor position. The cursor
   * position will be update to a previous sensible node too.
   * @method removeNode
   * @param {Object} DomNode to work on
   * @param {Array} Optional extra info, which will be passed around when triggering update events.
   *
   * @return returns node we ended up in.
   * @public
   */
  removeNode(node, extraInfo = []){
    //keeps track of current node.
    let carretPositionToEndIn = this.getRelativeCursorPosition();
    let nodeToEndIn = this.currentNode;
    let keepCurrentPosition = !node.isSameNode(nodeToEndIn) &amp;&amp; !node.contains(nodeToEndIn);

    if(!keepCurrentPosition){
      nodeToEndIn = previousTextNode(node, this.rootNode);
      carretPositionToEndIn = nodeToEndIn.length;
    }

    //find rich node matching dom node
    let richNode = this.getRichNodeFor(node);
    if(!richNode) return null;

    // proceed with removal
    removeNode(richNode.domNode);

    this.updateRichNode();
    this.generateDiffEvents.perform(extraInfo);

    this.setCarret(nodeToEndIn, carretPositionToEndIn);

    return nodeToEndIn;
  }

  /**
   * Prepends the children of a node with an html block
   * @method prependChildrenHTML
   * @param {Object} DomNode to work on
   * @param {Object} string containing html
   * @param {Boolean} instructive to place cursor after inserted HTML,
   * @param {Array} Optional extra info, which will be passed around when triggering update events.
   *
   * @return returns inserted domNodes (with possibly an extra trailing textNode).
   * @public
   */
  prependChildrenHTML(node, html, placeCursorAfterInsertedHtml = false, extraInfo = []){
    //TODO: check if node allowed children?
    let getCurrentCarretPosition = this.getRelativeCursorPosition();
    let currentNode = this.currentNode;

    let keepCurrentPosition = !placeCursorAfterInsertedHtml;

    //find rich node matching dom node
    let richParent = this.getRichNodeFor(node);
    if(!richParent) return null;

    //insert new nodes first
    let domNodesToInsert = createElementsFromHTML(html);

    if (domNodesToInsert.length == 0)
      return [ node ];

    let lastInsertedRichElement = this.prependElementsRichNode(richParent, domNodesToInsert);
    lastInsertedRichElement = this.insertValidCursorNodeAfterRichNode(richParent, lastInsertedRichElement);

    //update editor state
    const textNodeAfterInsert = !keepCurrentPosition ? nextTextNode(lastInsertedRichElement.domNode) : null;
    this.updateRichNode();
    this.generateDiffEvents.perform(extraInfo);
    if(keepCurrentPosition) {
      this.setCarret(currentNode, getCurrentCarretPosition);
    }
    else {
      this.setCarret(textNodeAfterInsert,0);
    }

    if(lastInsertedRichElement.domNode.isSameNode(domNodesToInsert.slice(-1)[0]))
      return domNodesToInsert;
    return [...domNodesToInsert, lastInsertedRichElement.domNode];
  }

  /**
   * inserts an emtpy textnode after richnode, if non existant.
   *
   * @method insertElementsAfterRichNode
   *
   * @param {RichNode} parent element where the elements should be added.
   * @param {RichNode} last sibling where new elements should occur after
   * @param {Array} array of (DOM) elements to insert
   *
   * @return {RichNode} returns last inserted element as RichNode. That is a rich textNode
   * @private
   */
  insertValidCursorNodeAfterRichNode(richParent, richNode){
    if (richNode.domNode.nextSibling === null || richNode.domNode.nextSibling.nodeType !== Node.TEXT_NODE) {
      let newNode = document.createTextNode(invisibleSpace);
      return this.insertElementsAfterRichNode(richParent, richNode, [newNode]);
    }
    return walkDomNodeAsText(richNode.domNode.nextSibling, richParent.domNode, richNode.end);
  }

  /**
   * Prepends a list of elements to children
   *
   * @method prependElementsRichNode
   *
   * @param {RichNode} parent element where the elements should be added.
   * @param {Array} array of (DOM) elements to insert
   *
   * @return {RichNode} returns last inserted element as RichNode
   * @private
   */
  prependElementsRichNode(richParent, elements){
    let newFirstChild = elements[0];
    if(richParent.domNode.firstChild)
      richParent.domNode.insertBefore(newFirstChild, richParent.domNode.firstChild);
    else
      richParent.domNode.appendChild(newFirstChild);

    let newFirstRichChild = walkDomNodeAsText(newFirstChild, richParent.domNode, richParent.start);
    return this.insertElementsAfterRichNode(richParent, newFirstRichChild, elements.slice(1));
  }

  /**
   * Inserts an array of elements into the editor.
   *
   * @method insertElementsAfterRichNode
   *
   * @param {RichNode} parent element where the elements should be added.
   * @param {RichNode} last sibling where new elements should occur after
   * @param {Array} array of (DOM) elements to insert
   *
   * @return {RichNode} returns last inserted element as RichNode
   * @private
   */
  insertElementsAfterRichNode(richParent, richNode, remainingElements){
    if( remainingElements.length == 0 )
      return richNode;

    let nodeToInsert = remainingElements[0];

    insertNodeBAfterNodeA(richParent.domNode, richNode.domNode, nodeToInsert);

    let richNodeToInsert = walkDomNodeAsText(nodeToInsert, richParent.domNode, richNode.end);

    return this.insertElementsAfterRichNode(richParent, richNodeToInsert, remainingElements.slice(1));
  }

  /**
   * Higlight a section of the editor text
   *
   * @method highlightRange
   *
   * @param {number} start Start of the region
   * @param {number} end End of the region
   * @param {Object} data map of data to be included on the highlight, can be used to add rdfa or data- attributes
   * @public
   */
  highlightRange(start, end, data = {}) {
    if( data &amp;&amp; Object.entries(data).length != 0 ) {
      warn( &quot;Data attributes were supplied to highlightRange but this is not supported at the moment&quot;, {id: &quot;content-editable.highlight&quot;} );
    }
    const selection = this.selectHighlight([start,end]);
    applyProperty(selection, this, highlightProperty); // todo: replace &#x27;this&#x27; with proper interface
    if (this.currentPosition &gt;= start &amp;&amp; this.currentPosition &lt;= end) {
      // cursor was in highlight, reset cursor
      const richNode = this.getRichNodeFor(this.currentNode);
      if (richNode) {
        this.setCarret(richNode.domNode, Math.max(0,this.currentPosition - richNode.start));
      }
      else {
        this.set(&#x27;currentNode&#x27;, null);
        this.setCurrentPosition(this.currentPosition);
      }
    }
  }

  /**
   * Clear the highlights contained in a specified range
   *
   * @method clearHightlightForRange
   *
   * @param {number} start Start of the range
   * @param {number} end End of the range
   *
   * @public
   */
  clearHighlightForRange(start,end) {
    console.warn(&#x27;deprecated call to clearHightlightForRange, use clearHighlightForLocations&#x27;, console.trace()); // eslint-disable-line no-console
    this.clearHighlightForLocations([start, end]);
  }

  /**
   * Given a list of locations, clear the linked highlight
   *
   * @method clearHighlightForLocations
   *
   * @param {Array} [[start, end], ...,[start, end]]
   *
   * @public
   */
  clearHighlightForLocations(locations){
    for (let location of locations) {
      cancelProperty(this.selectHighlight(location), this, highlightProperty); // todo: replace &#x27;this&#x27; with proper interface
      if (this.currentPosition &gt;= location[0] &amp;&amp; this.currentPosition &lt;= location[1]) {
        // cursor was in highlight, reset cursor
        const richNode = this.getRichNodeFor(this.currentNode);
        if (richNode) {
          this.setCarret(richNode.domNode, Math.max(0,this.currentPosition - richNode.start));
        }
        else {
          this.set(&#x27;currentNode&#x27;, null);
          this.setCurrentPosition(this.currentPosition);
        }
      }
    }
  }


  /**
   * Whether an element is displayed as a block
   *
   * @method isDisplayedAsBlock
   *
   * @param {RichNode} richNode Node to validate
   *
   * @return {boolean} true iff the element is displayed as a block
   *
   * @private
   */
  isDisplayedAsBlock(richNode) {
    isDisplayedAsBlock(get(richNode, &#x27;domNode&#x27;));
  }

  /**
   * Informs the consumer that the text was inserted at the given
   * position.
   *
   * Others can set it on this component, but we are the only ones to
   * call it.
   *
   * @param {number} position Index of the inserted text.
   * @param {String} text Text content that has been inserted.
   */
  textInsert( /*position, text*/ ) {
    warn(&quot;textInsert was called on raw-editor without listeners being set.&quot;, { id: &#x27;content-editable.invalid-state&#x27;});
  }

  /**
   * Insert text at provided position,
   *
   * @method insertText
   * @param {String} text to insert
   * @param {Number} position
   *
   * @return {DOMNode} node
   * @public
   */
  insertText(text, position) {
    if (!this.get(&#x27;richNode&#x27;)) {
      warn(&#x60;richNode wasn&#x27;t set before inserting text onposition ${position}&#x60;,{id: &#x27;content-editable.rich-node-not-set&#x27;});
      this.updateRichNode();
    }
    const textNode = this.findSuitableNodeForPosition(position);
    const type = get(textNode, &#x27;type&#x27;);
    let domNode;
    if (type === &#x27;text&#x27;) {
      if (text === &quot; &quot;)
        text = NON_BREAKING_SPACE;
      const parent = get(textNode, &#x27;parent&#x27;);
      if (position === get(textNode, &#x27;end&#x27;) &amp;&amp; tagName(get(parent, &#x27;domNode&#x27;)) === &#x27;mark&#x27;) {
        const mark = get(parent, &#x27;domNode&#x27;);
        const markParent = get(parent, &#x27;parent.domNode&#x27;);
        // there is no inserting at the end of highlight, we insert next to the highlight
        domNode = document.createTextNode(text);
        insertNodeBAfterNodeA(markParent, mark, domNode);
      }
      else {
        domNode = get(textNode, &#x27;domNode&#x27;);
        const relativePosition = position - get(textNode, &#x27;start&#x27;);
        if (text !== NON_BREAKING_SPACE &amp;&amp; relativePosition &gt; 0 &amp;&amp;
            domNode.textContent[relativePosition-1] === NON_BREAKING_SPACE) {
          let content = domNode.textContent;
          domNode.textContent = content.slice(0, relativePosition -1) + &quot; &quot; + content.slice(relativePosition);
        }
        sliceTextIntoTextNode(domNode, text, relativePosition);
      }
      this.set(&#x27;currentNode&#x27;, domNode);
    }
    else {
      // we should always have a suitable node... last attempt to safe things somewhat
      warn(&#x60;no text node found at position ${position}&#x60;, {id: &#x27;content-editable.no-text-node-found&#x27;});
      warn(&#x27;inconsistent state in editor!&#x27;, {id: &#x27;content-editable.no-text-node-found&#x27;});
      domNode = document.createTextNode(text);
      get(textNode, &#x27;domNode&#x27;).appendChild(domNode);
      this.set(&#x27;currentNode&#x27;, domNode);
    }
    this.updateRichNode();
    return domNode;
  }

  /**
   * insert a component at the provided position
   * @method insertComponent
   * @param {Number} position
   * @param {String} componentName
   * @param {Object} componentContent
   * @return {String} componentID
   * @public
   */
  insertComponent(position, name, content, id = uuidv4()) {
    var el;
    if (position instanceof Element)
      el = position;
    else
      [el] = this.replaceTextWithHTML(position, position, &#x60;&lt;div contenteditable=&quot;false&quot; id=&quot;editor-${id}&quot;&gt;&lt;!-- component ${id} --&gt;&lt;/div&gt;&#x60;);
    let config = { id, element: el, name, content: EmberObject.create(content) };
    this.components.pushObject(config);
    this.updateRichNode();
    this.updateSelectionAfterComplexInput();
    return id;
  }

  /**
   * remove a component
   * @method removeComponent
   * @param {String} componentID
   * @public
   */
  removeComponent(id) {
    let item = this.components.find( (item) =&gt; item.id === id);
    this.components.removeObject(item);
    this.updateRichNode();
    this.updateSelectionAfterComplexInput();
  }

  isTagWithOnlyABreakAsChild(node) {
    let type = node.domNode.nodeType;
    let children = get(node, &#x27;children&#x27;);
    return (type === Node.ELEMENT_NODE &amp;&amp;
            children.length === 1 &amp;&amp;
            get(children[0], &#x27;type&#x27;) === &#x27;tag&#x27; &amp;&amp;
            tagName(get(children[0], &#x27;domNode&#x27;)) === &#x27;br&#x27;
           );
  }

  insertTextNodeWithSpace(parent, relativeToSibling = null, after = false) {
    let parentDomNode = get(parent, &#x27;domNode&#x27;);
    let textNode = insertTextNodeWithSpace(parentDomNode, relativeToSibling, after);
    this.updateRichNode();
    this.generateDiffEvents.perform([{noSnapshot: true}]);
    return this.getRichNodeFor(textNode);
  }


  /**
   * determines best suitable node to position caret in for provided rich node and position
   * creates a text node if necessary
   * @method findSuitableNodeInRichNode
   * @param {RichNode} node
   * @param {number} position
   * @return {RichNode}
   * @private
   */
  findSuitableNodeInRichNode(node, position) {
    if (!node)
      throw new Error(&#x27;no node provided to findSuitableNodeinRichNode&#x27;);
    let type = node.type;
    // in some browsers voidElements don&#x27;t implement the interface of an element
    // for positioning we provide it&#x27;s own type
    if (isVoidElement(node.domNode))
      type = &#x27;void&#x27;;
    if (type === &#x27;text&#x27;) {
      return node;
    }
    else if (type === &#x27;void&#x27;) {
      let textNode = document.createTextNode(invisibleSpace);
      let parent = get(node, &#x27;parent&#x27;);
      let parentDomNode = get(parent,&#x27;domNode&#x27;);
      let children = get(parent, &#x27;children&#x27;);
      parentDomNode.replaceChild(textNode, node.domNode);
      if(children.length &gt; 1 &amp;&amp; tagName(get(node,&#x27;domNode&#x27;)) === &#x27;br&#x27;)
        parentDomNode.insertBefore(document.createElement(&#x27;br&#x27;), textNode); // new br to work around funky br type=&quot;moz&quot;
      else if (children.length !== 1 || tagName(get(node,&#x27;domNode&#x27;)) !== &#x27;br&#x27;)
        parentDomNode.insertBefore(node.domNode, textNode); // restore original void element
      this.updateRichNode();
      return this.getRichNodeFor(textNode);
    }
    else if (type === &#x27;tag&#x27;) {
      if (this.isTagWithOnlyABreakAsChild(node)) {
        debug(&#x27;suitable node: is tag with only a break as child&#x27;);
        let domNode = node.domNode;
        let textNode = document.createTextNode(invisibleSpace);
        domNode.replaceChild(textNode, domNode.firstChild);
        this.updateRichNode();
        return this.getRichNodeFor(textNode);
      }
      else {
        debug(&#x27;suitable node: using deepest matching node&#x27;);
        let appropriateNodeFilter = node =&gt;
            node.start &lt;= position &amp;&amp; node.end &gt;= position
            &amp;&amp; ! isVoidElement(node.domNode)
            &amp;&amp; ! isIgnorableElement(node.domNode)
            &amp;&amp; node.type !== &#x27;other&#x27;;
        let nodesContainingPosition = flatMap(node, appropriateNodeFilter);
        if (nodesContainingPosition.length &gt; 0) {
          let deepestContainingNode = nodesContainingPosition[nodesContainingPosition.length -1];
          if (deepestContainingNode === node) {
            debug(&#x60;creating new textnode in provided node of type ${node.type} range ${node.start} ${node.end}&#x60;);
            return this.insertTextNodeWithSpace(node);
          }
          else {
            debug(&#x27;retrying&#x27;);
            return this.findSuitableNodeInRichNode(deepestContainingNode, position);
          }
        }
        else {
          return this.insertTextNodeWithSpace(node);
        }
      }
    }
    throw new Error(&#x60;unsupported node type ${type} for richNode&#x60;);
  }

  /**
   * select a node based on the provided caret position, taking into account the current active node
   * if no suitable node exists, create one (within reason)
   * @method findSuitableNodeForPosition
   * @param {Number} position
   * @return {RichNode} node containing position or null if not found
   * @private
   */
  findSuitableNodeForPosition(position) {
    let currentRichNode = this.getRichNodeFor(this.get(&#x27;currentNode&#x27;));
    let richNode = this.get(&#x27;richNode&#x27;);
    if (currentRichNode &amp;&amp; get(currentRichNode, &#x27;start&#x27;) &lt;= position &amp;&amp; get(currentRichNode, &#x27;end&#x27;) &gt;= position) {
      let node = this.findSuitableNodeInRichNode(currentRichNode, position);
      return node;
    }
    else if (get(richNode, &#x27;start&#x27;) &lt;= position &amp;&amp; get(richNode, &#x27;end&#x27;) &gt;= position){
      let node = this.findSuitableNodeInRichNode(this.get(&#x27;richNode&#x27;),position);
      return node;
    }
    else {
      warn(&#x60;position ${position} is not in range of document ${get(richNode, &#x27;start&#x27;)} ${get(richNode, &#x27;end&#x27;)}&#x60;, {id: &#x27;content-editable:not-a-suitable-position&#x27;});
      return this.findSuitableNodeForPosition(get(richNode, &#x27;end&#x27;));
    }
  }

  /**
   * create a snapshot for undo history
   * @method createSnapshot
   * @public
   */
  createSnapshot() {
    let document = {
      content: this.get(&#x27;rootNode&#x27;).innerHTML,
      currentSelection: this.currentSelection
    };
    this.get(&#x27;history&#x27;).push(document);
  }

  /**
   * @method updateRichNode
   * @private
   */
  updateRichNode() {
    const richNode = walkDomNode( this.rootNode );
    this.set(&#x27;richNode&#x27;, richNode);
  }

  /**
   * restore a snapshot from undo history
   * @method undo
   * @public
   */
  undo() {
    let previousSnapshot = this.get(&#x27;history&#x27;).pop();
    if (previousSnapshot) {
      this.get(&#x27;rootNode&#x27;).innerHTML = previousSnapshot.content;
      this.updateRichNode();
      this.set(&#x27;currentNode&#x27;, null);
      this.setCurrentPosition(previousSnapshot.currentSelection[0]);
      this.generateDiffEvents.perform([{noSnapshot: true}]);
    }
    else {
      warn(&#x27;no more history to undo&#x27;, {id: &#x27;contenteditable-editor:history-empty&#x27;});
    }
  }

  /**
   * @method moveCaretInTextNode
   * @param {TEXTNode} textNode
   * @param {number} position
   * @private
   */
  moveCaretInTextNode(textNode, position){
    let docRange = document.createRange();
    let currentSelection = window.getSelection();
    docRange.setStart(textNode, position);
    docRange.collapse(true);
    currentSelection.removeAllRanges();
    currentSelection.addRange(docRange);
    this.get(&#x27;rootNode&#x27;).focus();
  }

   /**
   * get richnode matching a DOMNode
   *
   * @method getRichNodeFor
   *
   * @param {DOMNode} node
   *
   * @return {RichNode} node
   *
   * @private
   */
  getRichNodeFor(domNode, tree = this.get(&#x27;richNode&#x27;)) {
    return getRichNodeMatchingDomNode(domNode, tree);
  }

  /**
   * execute a DOM transformation on the editor content, ensures a consistent editor state
   * @method externalDomUpdate
   * @param {String} description
   * @param {function} domUpdate
   * @param {boolean} maintainCursor, keep cursor in place if possible
   * @public
   */
  externalDomUpdate(description, domUpdate, maintainCursor = false) {
    debug(&#x60;executing an external dom update: ${description}&#x60;, {id: &#x27;contenteditable.external-dom-update&#x27;} );
    const currentNode = this.currentNode;
    const richNode = this.getRichNodeFor(currentNode);
    if (richNode) {
      const relativePosition = this.getRelativeCursorPosition();
      domUpdate();
      this.updateRichNode();
      if (maintainCursor &amp;&amp;
          this.currentNode === currentNode &amp;&amp;
          this.rootNode.contains(currentNode) &amp;&amp;
          currentNode.length &gt;= relativePosition) {
        this.setCarret(currentNode,relativePosition);
      }
      else {
        this.updateSelectionAfterComplexInput();
      }
      forgivingAction(&#x27;elementUpdate&#x27;, this)();
      this.generateDiffEvents.perform();
    }
    else {
      domUpdate();
      this.updateRichNode();
      this.updateSelectionAfterComplexInput();
      forgivingAction(&#x27;elementUpdate&#x27;, this)();
      this.generateDiffEvents.perform();
    }
  }

  /**
   * update the selection based on dom window selection
   * to be used when we are unsure what sort of input actually happened
   *
   * @method updateSelectionAfterComplexInput
   * @private
   */
  updateSelectionAfterComplexInput() {
    let windowSelection = window.getSelection();
    if (windowSelection.rangeCount &gt; 0) {
      let range = windowSelection.getRangeAt(0);
      let commonAncestor = range.commonAncestorContainer;
      // IE does not support contains for text nodes
      commonAncestor = commonAncestor.nodeType === Node.TEXT_NODE ? commonAncestor.parentNode : commonAncestor;
      if (this.get(&#x27;rootNode&#x27;).contains(commonAncestor)) {
        if (range.collapsed) {
          this.setCarret(range.startContainer, range.startOffset);
        }
        else {
          let startNode = this.getRichNodeFor(range.startContainer);
          let endNode = this.getRichNodeFor(range.endContainer);
          let start = this.calculatePosition(startNode, range.startOffset);
          let end = this.calculatePosition(endNode, range.endOffset);
          let newSelection  = [start, end];
          this.set(&#x27;currentNode&#x27;, null);
          this.set(&#x27;currentSelection&#x27;, newSelection);
          forgivingAction(&#x27;selectionUpdate&#x27;, this)(this.get(&#x27;currentSelection&#x27;));
        }
      }
    }
    else {
      warn(&#x27;no selection found on window&#x27;,{ id: &#x27;content-editable.unsupported-browser&#x27;});
    }
  }

  /**
   * calculate the cursor position based on a richNode and an offset from a domRANGE
   * see https://developer.mozilla.org/en-US/docs/Web/API/Range/endOffset and
   * https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset
   *
   * @method calculatePosition
   * @param {RichNode} node
   * @param {Number} offset
   * @private
   */
  calculatePosition(richNode, offset) {
    let type = richNode.type;
    if (type === &#x27;text&#x27;)
      return richNode.start + offset;
    else if (type === &#x27;tag&#x27;) {
      let children = richNode.children;
      if (children &amp;&amp; children.length &gt; offset)
        return children[offset].start;
      else if (children &amp;&amp; children.length == offset)
        // this happens and in that case we want to be at the end of that node, but not outside
        return children[children.length -1 ].end;
      else {
        warn(&#x60;provided offset (${offset}) is invalid for richNode of type tag with ${children.length} children&#x60;, {id: &#x27;contenteditable-editor.invalid-range&#x27;});
        return children[children.length -1 ].end;
      }
    }
    else {
      throw new Error(&#x60;can&#x27;t calculate position for richNode of type ${type}&#x60;);
    }
  }

  /**
   * set the carret position in the editor
   *
   * @method setCurrentPosition
   * @param {number} position of the range
   * @param {boolean} notify observers, default true
   * @public
   */
  setCurrentPosition(position, notify = true) {
    let richNode = this.get(&#x27;richNode&#x27;);
    if (get(richNode, &#x27;end&#x27;) &lt; position || get(richNode, &#x27;start&#x27;) &gt; position) {
      warn(&#x60;received invalid position, resetting to ${get(richNode,&#x27;end&#x27;)} end of document&#x60;, {id: &#x27;contenteditable-editor.invalid-position&#x27;});
      position = get(richNode, &#x27;end&#x27;);
    }
    let node = this.findSuitableNodeForPosition(position);
    this.moveCaretInTextNode(get(node,&#x27;domNode&#x27;), position - node.start);
    this.set(&#x27;currentNode&#x27;, node.domNode);
    this.set(&#x27;currentSelection&#x27;, [ position, position ]);
    if (notify)
      forgivingAction(&#x27;selectionUpdate&#x27;, this)(this.currentSelection);
  }

  getRelativeCursorPosition(){
    let currentRichNode = this.getRichNodeFor(this.currentNode);
    if (currentRichNode) {
      let absolutePos = this.currentSelection[0];
      return absolutePos - currentRichNode.start;
    }
    return null;
  }

  getRelativeCursorPostion() {
    return this.getRelativeCursorPosition();
  }


  /**
   * set the carret on the desired position. This function ensures a text node is present at the requested position
   *
   * @method setCarret
   * @param {DOMNode} node, a text node or dom element
   * @param {number} offset, for a text node the relative offset within the text node (i.e. number of characters before the carret).
   *                         for a dom element the number of children before the carret.
   * @return {DOMNode} currentNode of the editor after the operation
   * Examples:
   *     to set the carret after &#x27;c&#x27; in a textnode with text content &#x27;abcd&#x27; use setCarret(textNode,3)
   *     to set the carret after the end of a node with innerHTML &#x60;&lt;b&gt;foo&lt;/b&gt;&lt;span&gt;work&lt;/span&gt;&#x60; use setCarret(element, 2) (e.g setCarret(element, element.children.length))
   *     to set the carret after the b in a node with innerHTML &#x60;&lt;b&gt;foo&lt;/b&gt;&lt;span&gt;work&lt;/span&gt;&#x60; use setCarret(element, 1) (e.g setCarret(element, indexOfChild + 1))
   *     to set the carret after the start of a node with innerHTML &#x60;&lt;b&gt;foo&lt;/b&gt;&lt;span&gt;work&lt;/span&gt;&#x60; use setCarret(element, 0)
   *
   * @public
   */
  setCarret(node, offset, notify = true) {
    const richNode = this.getRichNodeFor(node);
    if (!richNode)
      return;
    if (richNode.type === &#x27;tag&#x27; &amp;&amp; richNode.children) {
      if (richNode.children.length &lt; offset) {
        warn(&#x60;invalid offset ${offset} for node ${tagName(richNode.domNode)} with ${richNode.children } provided to setCarret&#x60;, {id: &#x27;contenteditable.invalid-start&#x27;});
        return;
      }
      const richNodeAfterCarret = richNode.children[offset];
      if (richNodeAfterCarret &amp;&amp; richNodeAfterCarret.type === &#x27;text&#x27;) {
        // the node after the carret is a text node, so we can set the cursor at the start of that node
        this.set(&#x27;currentNode&#x27;, richNodeAfterCarret.domNode);
        const absolutePosition = richNodeAfterCarret.start;
        this.set(&#x27;currentSelection&#x27;, [absolutePosition, absolutePosition]);
        this.moveCaretInTextNode(richNodeAfterCarret.domNode, 0);
      }
      else if (offset &gt; 0 &amp;&amp; richNode.children[offset-1].type === &#x27;text&#x27;) {
        // the node before the carret is a text node, so we can set the cursor at the end of that node
        const richNodeBeforeCarret = richNode.children[offset-1];
        this.set(&#x27;currentNode&#x27;, richNodeBeforeCarret.domNode);
        const absolutePosition = richNodeBeforeCarret.end;
        this.set(&#x27;currentSelection&#x27;, [absolutePosition, absolutePosition]);
        this.moveCaretInTextNode(richNodeBeforeCarret.domNode, richNodeBeforeCarret.domNode.textContent.length);
      }
      else {
        // no suitable text node is present, so we create a textnode
        // TODO: handle empty node
        var textNode;
        if (richNodeAfterCarret){
          textNode = insertTextNodeWithSpace(node, richNodeAfterCarret.domNode);
        }
        else{
          textNode = insertTextNodeWithSpace(node, richNode.children[offset-1].domNode, true);
        }
        this.updateRichNode();
        this.set(&#x27;currentNode&#x27;, textNode);
        const absolutePosition = this.getRichNodeFor(textNode).start;
        this.set(&#x27;currentSelection&#x27;, [absolutePosition, absolutePosition]);
        this.moveCaretInTextNode(textNode, 0);
      }
    }
    else if (richNode.type === &#x27;text&#x27;) {
      this.set(&#x27;currentNode&#x27;, node);
      const absolutePosition = richNode.start + offset;
      this.set(&#x27;currentSelection&#x27;, [absolutePosition, absolutePosition]);
      this.moveCaretInTextNode(node, offset);
    }
    else {
      warn(&#x60;invalid node ${tagName(node.domNode)} provided to setCarret&#x60;, {id: &#x27;contenteditable.invalid-start&#x27;});
    }
    if (notify)
      forgivingAction(&#x27;selectionUpdate&#x27;, this)(this.currentSelection);
  }

  insertUL() {
    unorderedListAction(this);
  }

  insertOL() {
    orderedListAction(this);
  }

  insertIndent() {
    indentAction(this);
  }

  insertUnindent() {
    unindentAction(this);
  }

  /* Potential methods for the new API */
  getContexts(options) {
    const {region} = options || {};
    if( region )
      return scanContexts( this.rootNode, region );
    else
      return scanContexts( this.rootNode );
  }

  /**
   * Pernet API
   * TODO: remove these methods once plugins switched to the new editor
   */
  selectCurrentSelection() {
    return selectCurrentSelection.bind(this)(...arguments);
  }
  selectHighlight() {
    return selectHighlight.bind(this)(...arguments);
  }
  selectContext() {
    return selectContext.bind(this)(...arguments);
  }
  update() {
    return update.bind(this)(...arguments);
  }
  replaceDomNode() {
    return replaceDomNode.bind(this)(...arguments);
  }
}

function uuidv4() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =&gt; {
    return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16);
  });
}
export default RawEditor;

    </pre>
</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script>prettyPrint();</script>
    <script src="../assets/vendor/jquery/jquery.min.js"></script>
    <script src="../assets/vendor/jquery-ui/jquery-ui.min.js"></script>
    <script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
    <script src="../assets/vendor/github-slugger/slugger.js"></script>
    <script src="../assets/js/yuidoc-bootstrap.js"></script>
</body>
</html>
